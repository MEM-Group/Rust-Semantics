verifying rust_tests/rv/race/concurorder-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 4 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 6 )
          var ( 2 ) |-> #sl ( 7 )
          var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 3 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) .cl valcl ( 0 ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
        </clstack>
      </Thread>
      <activeThreads>
        .Set
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        5
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 2
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 1
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 0
        funId ( 0 ) |-> 4
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V1 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        8
      </slocAddr>
      <sloc>
        0 |-> #own ( #blk ( 0 ) )
        1 |-> #uninit ( 0 )
        2 |-> #Raw ( #heap ( 3 , 0 ) )
        3 |-> #Raw ( #heap ( 3 , 0 ) )
        4 |-> #own ( #blk ( 4 ) )
        5 |-> #uninit ( 0 )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 0 , 0 ) |-> valcl ( V2 )
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 0 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 4 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 13 , 20 , #sl ( 4 ) )
        0 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 1 ) , 4 ) )
        SetItem ( #lread ( #sl ( 2 ) , 10 ) )
        SetItem ( #lread ( #sl ( 3 ) , 15 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 6 ) . valcl ( 0 ) , 20 ) )
        SetItem ( #lwrite ( #sl ( 1 ) , 5 ) )
        SetItem ( #lwrite ( #sl ( 5 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 0 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 0 ) |-> #ms ( 0 , 0 )
        #sl ( 1 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        20
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 4 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 6 )
          var ( 2 ) |-> #sl ( 7 )
          var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 3 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) .cl valcl ( 0 ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
        </clstack>
      </Thread>
      <activeThreads>
        .Set
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        5
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 2
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 1
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 0
        funId ( 0 ) |-> 4
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V1 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        8
      </slocAddr>
      <sloc>
        0 |-> #own ( #blk ( 0 ) )
        1 |-> #uninit ( 0 )
        2 |-> #Raw ( #heap ( 3 , 0 ) )
        3 |-> #Raw ( #heap ( 3 , 0 ) )
        4 |-> #own ( #blk ( 4 ) )
        5 |-> #uninit ( 0 )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 0 , 0 ) |-> valcl ( V2 )
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 0 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 4 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 13 , 20 , #sl ( 4 ) )
        0 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 1 ) , 4 ) )
        SetItem ( #lread ( #sl ( 2 ) , 10 ) )
        SetItem ( #lread ( #sl ( 3 ) , 17 ) )
        SetItem ( #lread ( #sl ( 5 ) , 15 ) )
        SetItem ( #lread ( #sl ( 6 ) . valcl ( 0 ) , 20 ) )
        SetItem ( #lwrite ( #sl ( 1 ) , 5 ) )
        SetItem ( #lwrite ( #sl ( 5 ) , 16 ) )
      </locRW>
      <memStatus>
        #heap ( 0 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 0 ) |-> #ms ( 0 , 0 )
        #sl ( 1 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        20
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 4 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 6 )
          var ( 2 ) |-> #sl ( 7 )
          var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 3 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) .cl valcl ( 0 ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
        </clstack>
      </Thread>
      <activeThreads>
        .Set
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        5
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 2
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 1
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 0
        funId ( 0 ) |-> 4
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V1 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        8
      </slocAddr>
      <sloc>
        0 |-> #own ( #blk ( 0 ) )
        1 |-> #uninit ( 0 )
        2 |-> #Raw ( #heap ( 3 , 0 ) )
        3 |-> #Raw ( #heap ( 3 , 0 ) )
        4 |-> #own ( #blk ( 4 ) )
        5 |-> #uninit ( 0 )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 0 , 0 ) |-> valcl ( V2 )
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 0 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 4 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 13 , 20 , #sl ( 4 ) )
        0 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 1 ) , 4 ) )
        SetItem ( #lread ( #sl ( 2 ) , 10 ) )
        SetItem ( #lread ( #sl ( 3 ) , 15 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 6 ) . valcl ( 0 ) , 20 ) )
        SetItem ( #lwrite ( #sl ( 1 ) , 5 ) )
        SetItem ( #lwrite ( #sl ( 5 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 0 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 0 ) |-> #ms ( 0 , 0 )
        #sl ( 1 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        20
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 4 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 6 )
          var ( 2 ) |-> #sl ( 7 )
          var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 3 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) .cl valcl ( 0 ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
        </clstack>
      </Thread>
      <activeThreads>
        .Set
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        5
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 2
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 1
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 0
        funId ( 0 ) |-> 4
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V1 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        8
      </slocAddr>
      <sloc>
        0 |-> #own ( #blk ( 0 ) )
        1 |-> #uninit ( 0 )
        2 |-> #Raw ( #heap ( 3 , 0 ) )
        3 |-> #Raw ( #heap ( 3 , 0 ) )
        4 |-> #own ( #blk ( 4 ) )
        5 |-> #uninit ( 0 )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 0 , 0 ) |-> valcl ( V2 )
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 0 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 4 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 13 , 20 , #sl ( 4 ) )
        0 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 1 ) , 4 ) )
        SetItem ( #lread ( #sl ( 2 ) , 10 ) )
        SetItem ( #lread ( #sl ( 3 ) , 17 ) )
        SetItem ( #lread ( #sl ( 5 ) , 15 ) )
        SetItem ( #lread ( #sl ( 6 ) . valcl ( 0 ) , 20 ) )
        SetItem ( #lwrite ( #sl ( 1 ) , 5 ) )
        SetItem ( #lwrite ( #sl ( 5 ) , 16 ) )
      </locRW>
      <memStatus>
        #heap ( 0 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 0 ) |-> #ms ( 0 , 0 )
        #sl ( 1 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        20
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/concurorder-spec.k"
	User time (seconds): 52.57
	System time (seconds): 1.03
	Percent of CPU this job got: 193%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:27.75
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1321792
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 515182
	Voluntary context switches: 12849
	Involuntary context switches: 2176
	Swaps: 0
	File system inputs: 0
	File system outputs: 280544
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/concurrace-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 4 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 6 )
          var ( 2 ) |-> #sl ( 7 )
          var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 3 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl var ( 5 ) .cl valcl ( 0 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
        </clstack>
      </Thread>
      <activeThreads>
        .Set
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        5
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 2
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 1
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 0
        funId ( 0 ) |-> 4
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V1 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        8
      </slocAddr>
      <sloc>
        0 |-> #own ( #blk ( 0 ) )
        1 |-> #uninit ( 0 )
        2 |-> #Raw ( #heap ( 3 , 0 ) )
        3 |-> #Raw ( #heap ( 3 , 0 ) )
        4 |-> #own ( #blk ( 4 ) )
        5 |-> #uninit ( 0 )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 0 , 0 ) |-> valcl ( V2 )
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 0 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 4 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 13 , 20 , #sl ( 4 ) )
        0 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 1 ) , 4 ) )
        SetItem ( #lread ( #sl ( 2 ) , 10 ) )
        SetItem ( #lread ( #sl ( 3 ) , 15 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 6 ) . valcl ( 0 ) , 20 ) )
        SetItem ( #lwrite ( #sl ( 1 ) , 5 ) )
        SetItem ( #lwrite ( #sl ( 5 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 0 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 0 ) |-> #ms ( 0 , 0 )
        #sl ( 1 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        20
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 4 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 6 )
          var ( 2 ) |-> #sl ( 7 )
          var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 3 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl var ( 5 ) .cl valcl ( 0 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
        </clstack>
      </Thread>
      <activeThreads>
        .Set
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        5
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 2
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 1
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 0
        funId ( 0 ) |-> 4
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V1 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        8
      </slocAddr>
      <sloc>
        0 |-> #own ( #blk ( 0 ) )
        1 |-> #uninit ( 0 )
        2 |-> #Raw ( #heap ( 3 , 0 ) )
        3 |-> #Raw ( #heap ( 3 , 0 ) )
        4 |-> #own ( #blk ( 4 ) )
        5 |-> #uninit ( 0 )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 0 , 0 ) |-> valcl ( V2 )
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 0 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 4 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 13 , 20 , #sl ( 4 ) )
        0 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 1 ) , 4 ) )
        SetItem ( #lread ( #sl ( 2 ) , 10 ) )
        SetItem ( #lread ( #sl ( 3 ) , 17 ) )
        SetItem ( #lread ( #sl ( 5 ) , 15 ) )
        SetItem ( #lread ( #sl ( 6 ) . valcl ( 0 ) , 20 ) )
        SetItem ( #lwrite ( #sl ( 1 ) , 5 ) )
        SetItem ( #lwrite ( #sl ( 5 ) , 16 ) )
      </locRW>
      <memStatus>
        #heap ( 0 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 0 ) |-> #ms ( 0 , 0 )
        #sl ( 1 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        20
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 4 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 6 )
          var ( 2 ) |-> #sl ( 7 )
          var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 3 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl var ( 5 ) .cl valcl ( 0 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
        </clstack>
      </Thread>
      <activeThreads>
        .Set
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        5
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 2
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 1
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 0
        funId ( 0 ) |-> 4
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V1 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        8
      </slocAddr>
      <sloc>
        0 |-> #own ( #blk ( 0 ) )
        1 |-> #uninit ( 0 )
        2 |-> #Raw ( #heap ( 3 , 0 ) )
        3 |-> #Raw ( #heap ( 3 , 0 ) )
        4 |-> #own ( #blk ( 4 ) )
        5 |-> #uninit ( 0 )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 0 , 0 ) |-> valcl ( V2 )
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 0 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 4 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 13 , 20 , #sl ( 4 ) )
        0 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 1 ) , 4 ) )
        SetItem ( #lread ( #sl ( 2 ) , 10 ) )
        SetItem ( #lread ( #sl ( 3 ) , 15 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 6 ) . valcl ( 0 ) , 20 ) )
        SetItem ( #lwrite ( #sl ( 1 ) , 5 ) )
        SetItem ( #lwrite ( #sl ( 5 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 0 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 0 ) |-> #ms ( 0 , 0 )
        #sl ( 1 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        20
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 4 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 6 )
          var ( 2 ) |-> #sl ( 7 )
          var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 3 )
          var ( 4 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 3 )
          var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl var ( 5 ) .cl valcl ( 0 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 )
          var ( 9 ) |-> #sl ( 2 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 )
          var ( 6 ) |-> #sl ( 1 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 0 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
        </clstack>
      </Thread>
      <activeThreads>
        .Set
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        5
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 2
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 1
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 0
        funId ( 0 ) |-> 4
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V1 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        8
      </slocAddr>
      <sloc>
        0 |-> #own ( #blk ( 0 ) )
        1 |-> #uninit ( 0 )
        2 |-> #Raw ( #heap ( 3 , 0 ) )
        3 |-> #Raw ( #heap ( 3 , 0 ) )
        4 |-> #own ( #blk ( 4 ) )
        5 |-> #uninit ( 0 )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 0 , 0 ) |-> valcl ( V2 )
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 0 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 4 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 13 , 20 , #sl ( 4 ) )
        0 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V4 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 1 ) , 4 ) )
        SetItem ( #lread ( #sl ( 2 ) , 10 ) )
        SetItem ( #lread ( #sl ( 3 ) , 17 ) )
        SetItem ( #lread ( #sl ( 5 ) , 15 ) )
        SetItem ( #lread ( #sl ( 6 ) . valcl ( 0 ) , 20 ) )
        SetItem ( #lwrite ( #sl ( 1 ) , 5 ) )
        SetItem ( #lwrite ( #sl ( 5 ) , 16 ) )
      </locRW>
      <memStatus>
        #heap ( 0 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 0 ) |-> #ms ( 0 , 0 )
        #sl ( 1 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        20
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/concurrace-spec.k"
	User time (seconds): 52.57
	System time (seconds): 0.88
	Percent of CPU this job got: 196%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:27.24
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1252684
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 483823
	Voluntary context switches: 12168
	Involuntary context switches: 1162
	Swaps: 0
	File system inputs: 0
	File system outputs: 280576
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t10-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V4 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V4 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V4 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V4 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V4 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V4 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V4 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V4 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t10-spec.k"
	User time (seconds): 55.50
	System time (seconds): 0.99
	Percent of CPU this job got: 198%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:28.47
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1322048
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 519091
	Voluntary context switches: 12308
	Involuntary context switches: 1910
	Swaps: 0
	File system inputs: 0
	File system outputs: 280608
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t12-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V4 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> valcl ( V4 )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 2 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #Raw ( #heap ( 4 , 0 ) )
        7 |-> #own ( #blk ( 5 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 6 ) )
        10 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 5 ) , 11 ) )
        SetItem ( #lread ( #sl ( 6 ) , 16 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V4 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> valcl ( V4 )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 2 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #Raw ( #heap ( 4 , 0 ) )
        7 |-> #own ( #blk ( 5 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 6 ) )
        10 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 5 ) , 11 ) )
        SetItem ( #lread ( #sl ( 6 ) , 18 ) )
        SetItem ( #lread ( #sl ( 8 ) , 16 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V4 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> valcl ( V4 )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 2 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #Raw ( #heap ( 4 , 0 ) )
        7 |-> #own ( #blk ( 5 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 6 ) )
        10 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 5 ) , 11 ) )
        SetItem ( #lread ( #sl ( 6 ) , 16 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V4 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> valcl ( V4 )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 2 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #Raw ( #heap ( 4 , 0 ) )
        7 |-> #own ( #blk ( 5 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 6 ) )
        10 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 5 ) , 11 ) )
        SetItem ( #lread ( #sl ( 6 ) , 18 ) )
        SetItem ( #lread ( #sl ( 8 ) , 16 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t12-spec.k"
	User time (seconds): 59.46
	System time (seconds): 1.10
	Percent of CPU this job got: 200%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:30.27
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1292716
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 528381
	Voluntary context switches: 12654
	Involuntary context switches: 1857
	Swaps: 0
	File system inputs: 0
	File system outputs: 280808
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t1-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V1 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> valcl ( V1 )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 3 , 0 ) )
        5 |-> #Raw ( #heap ( 3 , 0 ) )
        6 |-> #own ( #blk ( 4 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 5 ) )
        9 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 5 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 12 , 19 , #sl ( 6 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 3 ) )
        SetItem ( #lread ( #sl ( 4 ) , 9 ) )
        SetItem ( #lread ( #sl ( 5 ) , 14 ) )
        SetItem ( #lread ( #sl ( 7 ) , 15 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 19 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 4 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 16 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        19
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V1 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> valcl ( V1 )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 3 , 0 ) )
        5 |-> #Raw ( #heap ( 3 , 0 ) )
        6 |-> #own ( #blk ( 4 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 5 ) )
        9 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 5 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 12 , 19 , #sl ( 6 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 3 ) )
        SetItem ( #lread ( #sl ( 4 ) , 9 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 7 ) , 14 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 19 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 4 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 15 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        19
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V1 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> valcl ( V1 )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 3 , 0 ) )
        5 |-> #Raw ( #heap ( 3 , 0 ) )
        6 |-> #own ( #blk ( 4 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 5 ) )
        9 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 5 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 12 , 19 , #sl ( 6 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 3 ) )
        SetItem ( #lread ( #sl ( 4 ) , 9 ) )
        SetItem ( #lread ( #sl ( 5 ) , 14 ) )
        SetItem ( #lread ( #sl ( 7 ) , 15 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 19 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 4 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 16 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        19
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V1 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl var ( 5 ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> valcl ( V1 )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 3 , 0 ) )
        5 |-> #Raw ( #heap ( 3 , 0 ) )
        6 |-> #own ( #blk ( 4 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 5 ) )
        9 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 5 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 12 , 19 , #sl ( 6 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 3 ) )
        SetItem ( #lread ( #sl ( 4 ) , 9 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 7 ) , 14 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 19 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 4 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 15 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        19
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t1-spec.k"
	User time (seconds): 56.52
	System time (seconds): 1.01
	Percent of CPU this job got: 206%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:27.86
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1448924
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 563264
	Voluntary context switches: 12773
	Involuntary context switches: 1373
	Swaps: 0
	File system inputs: 0
	File system outputs: 280960
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t2-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V1 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl letcl var ( 11 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> valcl ( V1 )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 3 , 0 ) )
        5 |-> #Raw ( #heap ( 3 , 0 ) )
        6 |-> #own ( #blk ( 4 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 5 ) )
        9 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 5 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 12 , 19 , #sl ( 6 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 3 ) )
        SetItem ( #lread ( #sl ( 4 ) , 9 ) )
        SetItem ( #lread ( #sl ( 5 ) , 14 ) )
        SetItem ( #lread ( #sl ( 7 ) , 15 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 19 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 4 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 16 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        19
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V1 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl letcl var ( 11 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> valcl ( V1 )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 3 , 0 ) )
        5 |-> #Raw ( #heap ( 3 , 0 ) )
        6 |-> #own ( #blk ( 4 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 5 ) )
        9 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 5 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 12 , 19 , #sl ( 6 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 3 ) )
        SetItem ( #lread ( #sl ( 4 ) , 9 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 7 ) , 14 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 19 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 4 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 15 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        19
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V1 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl letcl var ( 11 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> valcl ( V1 )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 3 , 0 ) )
        5 |-> #Raw ( #heap ( 3 , 0 ) )
        6 |-> #own ( #blk ( 4 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 5 ) )
        9 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 5 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 12 , 19 , #sl ( 6 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 3 ) )
        SetItem ( #lread ( #sl ( 4 ) , 9 ) )
        SetItem ( #lread ( #sl ( 5 ) , 14 ) )
        SetItem ( #lread ( #sl ( 7 ) , 15 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 19 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 4 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 16 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        19
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V1 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl letcl var ( 11 ) =cl var ( 5 ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> valcl ( V1 )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 3 , 0 ) )
        5 |-> #Raw ( #heap ( 3 , 0 ) )
        6 |-> #own ( #blk ( 4 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 5 ) )
        9 |-> #Raw ( #heap ( 3 , 0 ) )
      </sloc>
      <blkAddr>
        6
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 3 , 1 ) |-> cr ( 5 )
        #heap ( 4 , 0 ) |-> valcl ( "" )
        #heap ( 5 , 0 ) |-> #shr ( 12 , 19 , #sl ( 6 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V2 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V3 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        4 |-> #blkInfo ( 1 , #owner ( str ) )
        5 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 3 ) )
        SetItem ( #lread ( #sl ( 4 ) , 9 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 7 ) , 14 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 19 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 4 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 15 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        19
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t2-spec.k"
	User time (seconds): 54.82
	System time (seconds): 0.82
	Percent of CPU this job got: 201%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:27.63
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1290604
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 512616
	Voluntary context switches: 12135
	Involuntary context switches: 1266
	Swaps: 0
	File system inputs: 0
	File system outputs: 281144
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t3-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 2 ) , #owner ( #array ( i32 , 2 ) ) , valcl ( V1 ) , valcl ( V2 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 4 , 0 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 6 ) )
        9 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V1 )
        #heap ( 1 , 1 ) |-> valcl ( V2 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 6 ) )
        1 |-> #blkInfo ( 2 , #owner ( #array ( i32 , 2 ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 4 ) , 11 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 7 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 2 ) , #owner ( #array ( i32 , 2 ) ) , valcl ( V1 ) , valcl ( V2 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 4 , 0 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 6 ) )
        9 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V1 )
        #heap ( 1 , 1 ) |-> valcl ( V2 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 6 ) )
        1 |-> #blkInfo ( 2 , #owner ( #array ( i32 , 2 ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 4 ) , 11 ) )
        SetItem ( #lread ( #sl ( 5 ) , 18 ) )
        SetItem ( #lread ( #sl ( 7 ) , 16 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 2 ) , #owner ( #array ( i32 , 2 ) ) , valcl ( V1 ) , valcl ( V2 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 4 , 0 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 6 ) )
        9 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V1 )
        #heap ( 1 , 1 ) |-> valcl ( V2 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 6 ) )
        1 |-> #blkInfo ( 2 , #owner ( #array ( i32 , 2 ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 4 ) , 11 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 7 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl clskip ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 2 ) , #owner ( #array ( i32 , 2 ) ) , valcl ( V1 ) , valcl ( V2 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 4 , 0 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 6 ) )
        9 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V1 )
        #heap ( 1 , 1 ) |-> valcl ( V2 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 6 ) )
        1 |-> #blkInfo ( 2 , #owner ( #array ( i32 , 2 ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 4 ) , 11 ) )
        SetItem ( #lread ( #sl ( 5 ) , 18 ) )
        SetItem ( #lread ( #sl ( 7 ) , 16 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t3-spec.k"
	User time (seconds): 52.19
	System time (seconds): 0.99
	Percent of CPU this job got: 195%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:27.23
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1155332
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 461677
	Voluntary context switches: 13966
	Involuntary context switches: 1143
	Swaps: 0
	File system inputs: 0
	File system outputs: 281288
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t4-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 2 ) , #owner ( #array ( i32 , 2 ) ) , valcl ( V1 ) , valcl ( V2 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 4 , 0 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 6 ) )
        9 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V1 )
        #heap ( 1 , 1 ) |-> valcl ( V2 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 6 ) )
        1 |-> #blkInfo ( 2 , #owner ( #array ( i32 , 2 ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 4 ) , 11 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 7 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 2 ) , #owner ( #array ( i32 , 2 ) ) , valcl ( V1 ) , valcl ( V2 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 4 , 0 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 6 ) )
        9 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V1 )
        #heap ( 1 , 1 ) |-> valcl ( V2 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 6 ) )
        1 |-> #blkInfo ( 2 , #owner ( #array ( i32 , 2 ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 4 ) , 11 ) )
        SetItem ( #lread ( #sl ( 5 ) , 18 ) )
        SetItem ( #lread ( #sl ( 7 ) , 16 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 2 ) , #owner ( #array ( i32 , 2 ) ) , valcl ( V1 ) , valcl ( V2 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 4 , 0 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 6 ) )
        9 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V1 )
        #heap ( 1 , 1 ) |-> valcl ( V2 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 6 ) )
        1 |-> #blkInfo ( 2 , #owner ( #array ( i32 , 2 ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 4 ) , 11 ) )
        SetItem ( #lread ( #sl ( 5 ) , 16 ) )
        SetItem ( #lread ( #sl ( 7 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 6 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 8 )
          var ( 2 ) |-> #sl ( 9 )
          var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 5 )
          var ( 4 ) |-> #sl ( 7 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 5 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 10 ) , letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 9 ) |-> #sl ( 4 ) ) )
          ListItem ( var ( 9 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 2 ) , #owner ( #array ( i32 , 2 ) ) , valcl ( V1 ) , valcl ( V2 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 9 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 7 ) , .Idents ) { letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 10 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 9 ) ) , .ExpCLs ) incl letcl var ( 11 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 10 ) ) , .ExpCLs ) ;cl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 7 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 8 ) =cl #move ( var ( 7 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 8 ) .cl valcl ( 0 ) ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        10
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #Raw ( #heap ( 4 , 0 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #own ( #blk ( 5 ) )
        7 |-> #uninit ( 0 )
        8 |-> #own ( #blk ( 6 ) )
        9 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V1 )
        #heap ( 1 , 1 ) |-> valcl ( V2 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 6 ) )
        1 |-> #blkInfo ( 2 , #owner ( #array ( i32 , 2 ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V3 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V4 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 4 ) , 11 ) )
        SetItem ( #lread ( #sl ( 5 ) , 18 ) )
        SetItem ( #lread ( #sl ( 7 ) , 16 ) )
        SetItem ( #lread ( #sl ( 8 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 7 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 1 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 7 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t4-spec.k"
	User time (seconds): 57.57
	System time (seconds): 0.94
	Percent of CPU this job got: 196%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:29.75
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1246608
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 481377
	Voluntary context switches: 12323
	Involuntary context switches: 1289
	Swaps: 0
	File system inputs: 0
	File system outputs: 281464
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t5-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V3 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> valcl ( V3 )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 2 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #Raw ( #heap ( 4 , 0 ) )
        7 |-> #own ( #blk ( 5 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 6 ) )
        10 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 5 ) , 11 ) )
        SetItem ( #lread ( #sl ( 6 ) , 16 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V3 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> valcl ( V3 )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 2 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #Raw ( #heap ( 4 , 0 ) )
        7 |-> #own ( #blk ( 5 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 6 ) )
        10 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 5 ) , 11 ) )
        SetItem ( #lread ( #sl ( 6 ) , 18 ) )
        SetItem ( #lread ( #sl ( 8 ) , 16 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V3 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> valcl ( V3 )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 2 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #Raw ( #heap ( 4 , 0 ) )
        7 |-> #own ( #blk ( 5 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 6 ) )
        10 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 5 ) , 11 ) )
        SetItem ( #lread ( #sl ( 6 ) , 16 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl valcl ( V3 ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl var ( 5 ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> valcl ( V3 )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 2 ) )
        5 |-> #Raw ( #heap ( 4 , 0 ) )
        6 |-> #Raw ( #heap ( 4 , 0 ) )
        7 |-> #own ( #blk ( 5 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 6 ) )
        10 |-> #Raw ( #heap ( 4 , 0 ) )
      </sloc>
      <blkAddr>
        7
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #own ( #blk ( 1 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 3 ) )
        #heap ( 4 , 1 ) |-> cr ( 5 )
        #heap ( 5 , 0 ) |-> valcl ( "" )
        #heap ( 6 , 0 ) |-> #shr ( 14 , 21 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        5 |-> #blkInfo ( 1 , #owner ( str ) )
        6 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 5 ) )
        SetItem ( #lread ( #sl ( 5 ) , 11 ) )
        SetItem ( #lread ( #sl ( 6 ) , 18 ) )
        SetItem ( #lread ( #sl ( 8 ) , 16 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 21 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 6 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 17 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        21
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t5-spec.k"
	User time (seconds): 53.89
	System time (seconds): 0.93
	Percent of CPU this job got: 197%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:27.82
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1285016
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 511489
	Voluntary context switches: 12953
	Involuntary context switches: 1357
	Swaps: 0
	File system inputs: 0
	File system outputs: 281688
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t6-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t6-spec.k"
	User time (seconds): 57.25
	System time (seconds): 1.00
	Percent of CPU this job got: 204%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:28.51
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1420440
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 539221
	Voluntary context switches: 12825
	Involuntary context switches: 1680
	Swaps: 0
	File system inputs: 0
	File system outputs: 281912
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t7-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t7-spec.k"
	User time (seconds): 55.65
	System time (seconds): 0.96
	Percent of CPU this job got: 204%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:27.69
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1416932
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 533885
	Voluntary context switches: 12170
	Involuntary context switches: 1341
	Swaps: 0
	File system inputs: 0
	File system outputs: 282112
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t8-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V3 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( 4 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V3 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V2 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t8-spec.k"
	User time (seconds): 55.09
	System time (seconds): 1.01
	Percent of CPU this job got: 201%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:27.83
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1540956
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 560524
	Voluntary context switches: 12733
	Involuntary context switches: 1391
	Swaps: 0
	File system inputs: 0
	File system outputs: 282320
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
verifying rust_tests/rv/race/t9-spec.k:
          
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V4 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V4 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ExpCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V4 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V4 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V4 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V4 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 17 ) )
        SetItem ( #lread ( #sl ( 8 ) , 18 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 19 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
#And
  <T>
    <threads>
      <Thread>
        <threadId>
          0
        </threadId>
        <tname>
          "main"
        </tname>
        <k>
          #readna ( #sl ( 7 ) ) ~> #freezer#rdLVfield1_ ( valcl ( false ) , valcl ( 0 ) ) ~> #freezer#Read0_ ( ) ~> #freezer#forkcl1_ ( refcl ( 1 , var ( 2 ) ) ) ~> #freezer#ExpCLs1_ ( .ValueCLs ) ~> #freezer#AllocateInit0_ ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) ~> #freezer#computeFB0_ ( )
        </k>
        <env>
          var ( 1 ) |-> #sl ( 9 )
          var ( 2 ) |-> #sl ( 10 )
          var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 )
        </env>
        <clstack>
          ListItem ( var ( 2 ) )
          ListItem ( var ( 1 ) )
          ListItem ( #state ( #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 3 ) |-> #sl ( 6 )
          var ( 4 ) |-> #sl ( 8 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 4 ) )
          ListItem ( var ( 3 ) |-> #sl ( 6 )
          var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) )
          ListItem ( var ( 3 ) )
          ListItem ( #state ( #freezer#letcl1_ ( var ( 11 ) , letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ) ) ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) ~> #freezer#computeFB0_ ( ) , var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 )
          var ( 10 ) |-> #sl ( 5 ) ) )
          ListItem ( var ( 10 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 )
          var ( 7 ) |-> #sl ( 4 ) )
          ListItem ( var ( 7 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 )
          var ( 6 ) |-> #sl ( 3 ) )
          ListItem ( var ( 6 ) )
          ListItem ( var ( 5 ) |-> #sl ( 2 ) )
          ListItem ( var ( 5 ) )
          ListItem ( .Map )
          ListItem ( #state ( . , .Map ) )
        </clstack>
      </Thread>
      <activeThreads>
        SetItem ( 0 )
      </activeThreads>
      <cntThreads>
        1
      </cntThreads>
      <cthread>
        0
      </cthread>
    </threads>
    <closures>
      <closureCnt>
        6
      </closureCnt>
      <funclosure>
        #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) |-> 4
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) |-> 3
        #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) |-> 2
        #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) |-> 1
        funId ( 0 ) |-> 5
        main |-> 0
      </funclosure>
      <closure>
        <crId>
          0
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| letcl var ( 5 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) , valcl ( V4 ) , .ExpCLs ) incl letcl var ( 6 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 7 ) =cl #AllocateInit ( valcl ( 1 ) , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) , #RawCL ( refcl ( 1 , var ( 5 ) ) ) , .ExpCLs ) incl letcl var ( 10 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 6 ) ) , .ExpCLs ) , fun funId ( 0 ) ( var ( 8 ) , .Idents ) { letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 11 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 10 ) ) , .ExpCLs ) incl letcl var ( 14 ) =cl #AllocateInitRaw ( valcl ( 2 ) , #owner ( #closureTy ( #envId ( 1 ) , fnTy ( .CoreTys ) -> #void ) ) , #AllocateInit ( valcl ( 1 ) , #IdTy ( #env ( 1 ) , #prod ( #fd ( r1 , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) , #move ( var ( 7 ) ) , .ExpCLs ) , fun funId ( 1 ) ( var ( 12 ) , .Idents ) { letcl var ( 13 ) =cl #move ( var ( 12 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 13 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V2 ) ;cl clskip ;cl clskip ) } , .ValueCLs ) incl letcl var ( 15 ) =cl callcl ( #cpath ( #owner ( #IdTy ( thread , #prod ( .Fields ) ) ) , spawn ) , #move ( var ( 14 ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 11 ) ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 16 ) =cl #move ( var ( 5 ) ) incl ( callcl ( #cpath ( #owner ( #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) ) , join ) , refcl ( 0 , var ( 15 ) ) , .ExpCLs ) ;cl clskip ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          1
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 3 ) , .Idents
        </crParams>
        <crBody>
          (| letcl var ( 4 ) =cl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , new ) , .ExpCLs ) incl callcl ( #cpath ( #owner ( #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) ) , spawn ) , #move ( var ( 4 ) ) , #move ( var ( 3 ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          2
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 1 ) , var ( 2 ) , .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( JoinHandle , #prod ( #fd ( handle , i32 ) , .Fields ) ) , #forkcl ( *cl na ( var ( 1 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) , refcl ( 1 , var ( 2 ) ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          3
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          .Idents
        </crParams>
        <crBody>
          (| #AllocateInit ( valcl ( 1 ) , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) , #refallocate ( #allocateInit ( valcl ( 1 ) , #owner ( str ) , valcl ( "" ) , .ValueCLs ) ) , .ExpCLs ) |)
        </crBody>
      </closure> <closure>
        <crId>
          4
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 0 ) , .Idents
        </crParams>
        <crBody>
          (| #wait ( *cl na var ( 0 ) .cl valcl ( 0 ) ) |)
        </crBody>
      </closure> <closure>
        <crId>
          5
        </crId>
        <crContext>
          .
        </crContext>
        <crParams>
          var ( 8 ) , .Idents
        </crParams>
        <crBody>
          letcl var ( 9 ) =cl #move ( var ( 8 ) .cl valcl ( 0 ) ) incl ( *cl na ( var ( 9 ) .cl valcl ( 0 ) ) .cl valcl ( 0 ) :=cl sc valcl ( V5 ) ;cl clskip ;cl clskip )
        </crBody>
      </closure>
    </closures>
    <memory>
      <slocAddr>
        11
      </slocAddr>
      <sloc>
        2 |-> #own ( #blk ( 1 ) )
        3 |-> #uninit ( 0 )
        4 |-> #own ( #blk ( 3 ) )
        5 |-> #Raw ( #heap ( 5 , 0 ) )
        6 |-> #Raw ( #heap ( 5 , 0 ) )
        7 |-> #own ( #blk ( 6 ) )
        8 |-> #uninit ( 0 )
        9 |-> #own ( #blk ( 7 ) )
        10 |-> #Raw ( #heap ( 5 , 0 ) )
      </sloc>
      <blkAddr>
        8
      </blkAddr>
      <blocks>
        #heap ( 1 , 0 ) |-> valcl ( V4 )
        #heap ( 2 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 3 , 0 ) |-> #Raw ( #sl ( 2 ) )
        #heap ( 4 , 0 ) |-> #own ( #blk ( 2 ) )
        #heap ( 5 , 0 ) |-> #own ( #blk ( 4 ) )
        #heap ( 5 , 1 ) |-> cr ( 5 )
        #heap ( 6 , 0 ) |-> valcl ( "" )
        #heap ( 7 , 0 ) |-> #shr ( 15 , 22 , #sl ( 7 ) )
        1 |-> #blkInfo ( 1 , #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) )
        2 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        3 |-> #blkInfo ( 1 , #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) )
        4 |-> #blkInfo ( 1 , #IdTy ( #env ( 0 ) , #prod ( #fd ( r , #owner ( #IdTy ( V0 , #prod ( #fd ( p , #raw ( #owner ( #IdTy ( V1 , #prod ( #fd ( x , i32 ) , .Fields ) ) ) ) ) , .Fields ) ) ) ) , .Fields ) ) )
        5 |-> #blkInfo ( 2 , #owner ( #closureTy ( #envId ( 0 ) , fnTy ( .CoreTys ) -> #void ) ) )
        6 |-> #blkInfo ( 1 , #owner ( str ) )
        7 |-> #blkInfo ( 1 , #IdTy ( V3 , #prod ( #fd ( name , #ref ( #owner ( str ) ) ) , .Fields ) ) )
      </blocks>
      <locRW>
        SetItem ( #lread ( #sl ( 3 ) , 6 ) )
        SetItem ( #lread ( #sl ( 5 ) , 12 ) )
        SetItem ( #lread ( #sl ( 6 ) , 19 ) )
        SetItem ( #lread ( #sl ( 8 ) , 17 ) )
        SetItem ( #lread ( #sl ( 9 ) . valcl ( 0 ) , 22 ) )
        SetItem ( #lwrite ( #sl ( 3 ) , 7 ) )
        SetItem ( #lwrite ( #sl ( 8 ) , 18 ) )
      </locRW>
      <memStatus>
        #heap ( 1 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 2 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 3 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 4 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 5 , 1 ) |-> #ms ( 0 , 0 )
        #heap ( 6 , 0 ) |-> #ms ( 0 , 0 )
        #heap ( 7 , 0 ) |-> #ms ( 0 , 0 )
        #sl ( 2 ) |-> #ms ( 0 , 0 )
        #sl ( 3 ) |-> #ms ( 0 , 0 )
        #sl ( 4 ) |-> #ms ( 0 , 0 )
        #sl ( 5 ) |-> #ms ( 0 , 0 )
        #sl ( 6 ) |-> #ms ( 0 , 0 )
        #sl ( 8 ) |-> #ms ( 0 , 0 )
        #sl ( 9 ) |-> #ms ( 0 , 0 )
        #sl ( 10 ) |-> #ms ( 0 , 0 )
      </memStatus>
      <clk>
        22
      </clk>
    </memory>
    <output>
      .List
    </output>
  </T>
Command exited with non-zero status 1
	Command being timed: "./clkprove rust_tests/rv/race/t9-spec.k"
	User time (seconds): 59.51
	System time (seconds): 0.96
	Percent of CPU this job got: 196%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:30.71
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 1300428
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 518966
	Voluntary context switches: 12865
	Involuntary context switches: 1406
	Swaps: 0
	File system inputs: 0
	File system outputs: 282536
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 1
