
//verification 1

module STRPOOL-SPEC

imports CLANG

rule <T>
       <threads>
	<thread>
	 <threadId> 0 </threadId>
	 <tname> "main" </tname>
	 <k>
	 fun #cpath ( #prodId ( StringPool ) , intern ) ( var ( 44 ) , var ( 45 ) , .Idents ) { (| letcl var ( 46 ) =cl callcl ( #cpath ( #prodId ( InternedString ) , from_str ) , var ( 45 ) , .ExpCLs ) incl ( #move ( callcl ( #cpath ( #prodId ( InternedString ) , from_str ) , var ( 45 ) , .ExpCLs ) ) ;cl letcl var ( 47 ) =cl callcl ( #cpath ( #prodId ( RefCell ) , borrow_mut ) , refcl ( #cvarcl ( *cl na var ( 44 ) .cl valcl ( 2 ) ) ) , .ExpCLs ) incl ( #move ( callcl ( #cpath ( #prodId ( RefCell ) , borrow_mut ) , refcl ( #cvarcl ( *cl na var ( 44 ) .cl valcl ( 2 ) ) ) , .ExpCLs ) ) ;cl letcl var ( 48 ) =cl callcl ( #cpath ( #prodId ( RefMut ) , get ) , refcl ( var ( 47 ) ) , .ExpCLs ) incl letcl var ( 49 ) =cl callcl ( #cpath ( #prodId ( HashMap ) , entry ) , var ( 48 ) , #moveVal ( var ( 46 ) , var ( 46 ) ) , .ExpCLs ) incl ( #move ( callcl ( #cpath ( #prodId ( HashMap ) , entry ) , var ( 48 ) , #moveVal ( var ( 46 ) , var ( 46 ) ) , .ExpCLs ) ) ;cl letcl var ( 50 ) =cl callcl ( #cpath ( #sumId ( Entry ) , or_insert_with ) , refcl ( var ( 49 ) ) , #moveVal ( callcl ( #cpath ( #prodId ( StringPool ) , do_intern ) , var ( 44 ) , var ( 45 ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( StringPool ) , do_intern ) , var ( 44 ) , var ( 45 ) , .ExpCLs ) ) , .ExpCLs ) incl #moveVal ( var ( 50 ) , var ( 50 ) ) ) ;cl #drop ( callcl ( #cpath ( #prodId ( RefMut ) , drop ) , refcl ( var ( 47 ) ) , .ExpCLs ) ) ) ) |) } ;cl fun #cpath ( #prodId ( StringPool ) , do_intern ) ( var ( 42 ) , var ( 43 ) , .Idents ) { (| callcl ( #cpath ( #prodId ( StringPool ) , ensure_capacity ) , var ( 42 ) , .ExpCLs ) ;cl clskip ;cl #moveVal ( callcl ( #cpath ( #prodId ( StringPool ) , store ) , var ( 42 ) , var ( 43 ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( StringPool ) , store ) , var ( 42 ) , var ( 43 ) , .ExpCLs ) ) |) }  ;cl fun #cpath ( #prodId ( StringPool ) , ensure_capacity ) ( var ( 41 ) , .Idents ) { (| callcl ( #cpath ( #prodId ( Cell ) , set ) , refcl ( #cvarcl ( *cl na var ( 41 ) .cl valcl ( 0 ) ) ) , #moveVal ( allocate ( valcl ( 1 ) , #TyUndef ) , allocate ( valcl ( 1 ) , #TyUndef ) ) , .ExpCLs ) ;cl clskip |) }  ;cl fun #cpath ( #prodId ( StringPool ) , store ) ( var ( 34 ) , var ( 35 ) , .Idents ) { (| letcl var ( 36 ) =cl callcl ( #cpath ( str , as_bytes ) , var ( 35 ) , .ExpCLs ) incl ( #move ( callcl ( #cpath ( str , as_bytes ) , var ( 35 ) , .ExpCLs ) ) ;cl letcl var ( 37 ) =cl callcl ( #cpath ( #prodId ( slice ) , as_ptr ) , refcl ( var ( 36 ) ) , .ExpCLs ) incl letcl var ( 38 ) =cl callcl ( #cpath ( str , len ) , var ( 35 ) , .ExpCLs ) incl letcl var ( 39 ) =cl callcl ( #cpath ( #prodId ( Cell ) , get ) , refcl ( #cvarcl ( *cl na var ( 34 ) .cl valcl ( 0 ) ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #prodId ( ptr ) , copy_nonoverlapping ) , var ( 37 ) , var ( 39 ) , valcl ( 1 ) , .ExpCLs ) ;cl clskip ;cl letcl var ( 40 ) =cl callcl ( #cpath ( #prodId ( InternedString ) , from_parts ) , var ( 39 ) , var ( 38 ) , .ExpCLs ) incl ( #move ( callcl ( #cpath ( #prodId ( InternedString ) , from_parts ) , var ( 39 ) , var ( 38 ) , .ExpCLs ) ) ;cl #forgetcl ( var ( 37 ) ) ;cl clskip ;cl #forgetcl ( var ( 39 ) ) ;cl clskip ;cl #moveVal ( var ( 40 ) , var ( 40 ) ) ) ) ) |) } ;cl fun #cpath ( #prodId ( StringPool ) , new ) ( .Idents ) { (| #moveVal ( allocateInit ( 0 |-> #moveVal ( callcl ( #cpath ( #prodId ( Cell ) , new ) , callcl ( #cpath ( #prodId ( ptr ) , null_mut ) , .ExpCLs ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( Cell ) , new ) , callcl ( #cpath ( #prodId ( ptr ) , null_mut ) , .ExpCLs ) , .ExpCLs ) )
        1 |-> #moveVal ( callcl ( #cpath ( #prodId ( Cell ) , new ) , valcl ( 0 ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( Cell ) , new ) , valcl ( 0 ) , .ExpCLs ) )
        2 |-> #moveVal ( callcl ( #cpath ( #prodId ( RefCell ) , new ) , #moveVal ( callcl ( #cpath ( #prodId ( HashMap ) , new ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( HashMap ) , new ) , .ExpCLs ) ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( RefCell ) , new ) , #moveVal ( callcl ( #cpath ( #prodId ( HashMap ) , new ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( HashMap ) , new ) , .ExpCLs ) ) , .ExpCLs ) ) , #prodId ( StringPool ) ) , allocateInit ( 0 |-> #moveVal ( callcl ( #cpath ( #prodId ( Cell ) , new ) , callcl ( #cpath ( #prodId ( ptr ) , null_mut ) , .ExpCLs ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( Cell ) , new ) , callcl ( #cpath ( #prodId ( ptr ) , null_mut ) , .ExpCLs ) , .ExpCLs ) )
        1 |-> #moveVal ( callcl ( #cpath ( #prodId ( Cell ) , new ) , valcl ( 0 ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( Cell ) , new ) , valcl ( 0 ) , .ExpCLs ) )
        2 |-> #moveVal ( callcl ( #cpath ( #prodId ( RefCell ) , new ) , #moveVal ( callcl ( #cpath ( #prodId ( HashMap ) , new ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( HashMap ) , new ) , .ExpCLs ) ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( RefCell ) , new ) , #moveVal ( callcl ( #cpath ( #prodId ( HashMap ) , new ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( HashMap ) , new ) , .ExpCLs ) ) , .ExpCLs ) ) , #prodId ( StringPool ) ) ) |) } ;cl fun #cpath ( #prodId ( InternedString ) , from_parts ) ( var ( 32 ) , var ( 33 ) , .Idents ) { (| #moveVal ( allocateInit ( 0 |-> #moveVal ( var ( 32 ) , var ( 32 ) )
        1 |-> #moveVal ( var ( 33 ) , var ( 33 ) ) , #prodId ( InternedString ) ) , allocateInit ( 0 |-> #moveVal ( var ( 32 ) , var ( 32 ) )
        1 |-> #moveVal ( var ( 33 ) , var ( 33 ) ) , #prodId ( InternedString ) ) ) |) } ;cl fun #cpath ( #prodId ( InternedString ) , from_str ) ( var ( 30 ) , .Idents ) { (| letcl var ( 31 ) =cl callcl ( #cpath ( str , as_bytes ) , var ( 30 ) , .ExpCLs ) incl ( #move ( callcl ( #cpath ( str , as_bytes ) , var ( 30 ) , .ExpCLs ) ) ;cl #moveVal ( allocateInit ( 0 |-> #moveVal ( callcl ( #cpath ( #prodId ( slice ) , as_ptr ) , refcl ( var ( 31 ) ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( slice ) , as_ptr ) , refcl ( var ( 31 ) ) , .ExpCLs ) )
        1 |-> #moveVal ( callcl ( #cpath ( #prodId ( slice ) , len ) , refcl ( var ( 31 ) ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( slice ) , len ) , refcl ( var ( 31 ) ) , .ExpCLs ) ) , #prodId ( InternedString ) ) , allocateInit ( 0 |-> #moveVal ( callcl ( #cpath ( #prodId ( slice ) , as_ptr ) , refcl ( var ( 31 ) ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( slice ) , as_ptr ) , refcl ( var ( 31 ) ) , .ExpCLs ) )
        1 |-> #moveVal ( callcl ( #cpath ( #prodId ( slice ) , len ) , refcl ( var ( 31 ) ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( slice ) , len ) , refcl ( var ( 31 ) ) , .ExpCLs ) ) , #prodId ( InternedString ) ) ) ) |) }  ;cl fun #cpath ( #prodId ( HashMap ) , entry ) ( var ( 28 ) , var ( 29 ) , .Idents ) { (| ifcl #mapKeyincl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) ==cl valcl ( 0 ) thencl (| #mapAddcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , #moveVal ( var ( 29 ) , var ( 29 ) ) , #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) ) ) ;cl clskip ;cl #mapAddcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) , #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) ) , #moveVal ( valcl ( 0 ) , valcl ( 0 ) ) ) ;cl clskip ;cl #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) :=cl sc #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) +cl valcl ( 1 ) ;cl clskip ;cl #moveVal ( allocateInit ( 0 |-> #moveVal ( valcl ( 1 ) , valcl ( 1 ) )
        1 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) ) , #prodId ( entry ) ) , allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) ) , #prodId ( entry ) ) ) , #prodId ( Vacant ) ) , allocateInit ( 0 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) ) , #prodId ( entry ) ) , allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) ) , #prodId ( entry ) ) ) , #prodId ( Vacant ) ) ) , #sumId ( Entry ) ) , allocateInit ( 0 |-> #moveVal ( valcl ( 1 ) , valcl ( 1 ) )
        1 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) ) , #prodId ( entry ) ) , allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) ) , #prodId ( entry ) ) ) , #prodId ( Vacant ) ) , allocateInit ( 0 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) ) , #prodId ( entry ) ) , allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) , #cvarcl ( *cl na var ( 28 ) .cl valcl ( 0 ) ) -cl valcl ( 1 ) ) , #prodId ( entry ) ) ) , #prodId ( Vacant ) ) ) , #sumId ( Entry ) ) ) |) elsecl (| #moveVal ( allocateInit ( 0 |-> #moveVal ( valcl ( 0 ) , valcl ( 0 ) )
        1 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) , #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) ) , #prodId ( entry ) ) , allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) , #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) ) , #prodId ( entry ) ) ) , #prodId ( Occupied ) ) , allocateInit ( 0 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) , #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) ) , #prodId ( entry ) ) , allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) , #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) ) , #prodId ( entry ) ) ) , #prodId ( Occupied ) ) ) , #sumId ( Entry ) ) , allocateInit ( 0 |-> #moveVal ( valcl ( 0 ) , valcl ( 0 ) )
        1 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) , #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) ) , #prodId ( entry ) ) , allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) , #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) ) , #prodId ( entry ) ) ) , #prodId ( Occupied ) ) , allocateInit ( 0 |-> #moveVal ( allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) , #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) ) , #prodId ( entry ) ) , allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) , refcl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 2 ) ) ) )
        1 |-> #moveVal ( #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) , #mapValuecl ( #cvarcl ( *cl na var ( 28 ) .cl valcl ( 1 ) ) , var ( 29 ) ) ) , #prodId ( entry ) ) ) , #prodId ( Occupied ) ) ) , #sumId ( Entry ) ) ) |) |) } ;cl fun #cpath ( #prodId ( HashMap ) , new ) ( .Idents ) { (| #moveVal ( allocateInit ( 0 |-> #moveVal ( valcl ( 0 ) , valcl ( 0 ) )
        1 |-> #moveVal ( allocate ( valcl ( 0 ) , #Map ) , allocate ( valcl ( 0 ) , #Map ) )
        2 |-> #moveVal ( allocate ( valcl ( 0 ) , #Map ) , allocate ( valcl ( 0 ) , #Map ) ) , #prodId ( HashMap ) ) , allocateInit ( 0 |-> #moveVal ( valcl ( 0 ) , valcl ( 0 ) )
        1 |-> #moveVal ( allocate ( valcl ( 0 ) , #Map ) , allocate ( valcl ( 0 ) , #Map ) )
        2 |-> #moveVal ( allocate ( valcl ( 0 ) , #Map ) , allocate ( valcl ( 0 ) , #Map ) ) , #prodId ( HashMap ) ) ) |) } ;cl fun #cpath ( #sumId ( Entry ) , or_insert_with ) ( var ( 24 ) , var ( 25 ) , .Idents ) { (| (| casecl { #cvarcl ( *cl na var ( 24 ) .cl valcl ( 0 ) ) ==cl valcl ( 0 ) &&cl valcl ( 0 ) -> (| letcl var ( 26 ) =cl #cvarcl ( #cvarcl ( *cl na var ( 24 ) .cl valcl ( 1 ) ) .cl valcl ( 0 ) ) incl ( #move ( #cvarcl ( #cvarcl ( *cl na var ( 24 ) .cl valcl ( 1 ) ) .cl valcl ( 0 ) ) ) ;cl #moveVal ( callcl ( #cpath ( #prodId ( entry ) , intomut ) , refcl ( var ( 26 ) ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( entry ) , intomut ) , refcl ( var ( 26 ) ) , .ExpCLs ) ) ) |) ; #cvarcl ( *cl na var ( 24 ) .cl valcl ( 0 ) ) ==cl valcl ( 1 ) &&cl valcl ( 0 ) -> (| letcl var ( 27 ) =cl #cvarcl ( #cvarcl ( *cl na var ( 24 ) .cl valcl ( 1 ) ) .cl valcl ( 0 ) ) incl ( #move ( #cvarcl ( #cvarcl ( *cl na var ( 24 ) .cl valcl ( 1 ) ) .cl valcl ( 0 ) ) ) ;cl #moveVal ( callcl ( #cpath ( #prodId ( entry ) , insert ) , refcl ( var ( 27 ) ) , var ( 25 ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( entry ) , insert ) , refcl ( var ( 27 ) ) , var ( 25 ) , .ExpCLs ) ) ) |) ; .GuardedActions } |) ;cl clskip ;cl clskip ;cl #forgetcl ( var ( 25 ) ) ;cl clskip |) } ;cl fun #cpath ( #prodId ( entry ) , intomut ) ( var ( 23 ) , .Idents ) { (| #moveVal ( refcl ( #mapValuecl ( *cl na #cvarcl ( *cl na var ( 23 ) .cl valcl ( 0 ) ) , #cvarcl ( *cl na var ( 23 ) .cl valcl ( 1 ) ) ) ) , refcl ( #mapValuecl ( *cl na #cvarcl ( *cl na var ( 23 ) .cl valcl ( 0 ) ) , #cvarcl ( *cl na var ( 23 ) .cl valcl ( 1 ) ) ) ) ) |) }  ;cl fun #cpath ( #prodId ( entry ) , insert ) ( var ( 21 ) , var ( 22 ) , .Idents ) { (| #mapAddcl ( *cl na #cvarcl ( *cl na var ( 21 ) .cl valcl ( 0 ) ) , #moveVal ( #cvarcl ( *cl na var ( 21 ) .cl valcl ( 1 ) ) , #cvarcl ( *cl na var ( 21 ) .cl valcl ( 1 ) ) ) , #moveVal ( var ( 22 ) , var ( 22 ) ) ) ;cl clskip ;cl #moveVal ( refcl ( #mapValuecl ( *cl na #cvarcl ( *cl na var ( 21 ) .cl valcl ( 0 ) ) , #cvarcl ( *cl na var ( 21 ) .cl valcl ( 1 ) ) ) ) , refcl ( #mapValuecl ( *cl na #cvarcl ( *cl na var ( 21 ) .cl valcl ( 0 ) ) , #cvarcl ( *cl na var ( 21 ) .cl valcl ( 1 ) ) ) ) ) |) } ;cl fun #cpath ( str , as_bytes ) ( var ( 20 ) , .Idents ) { (| #moveVal ( allocateInit ( 0 |-> #moveVal ( var ( 20 ) , var ( 20 ) )
        1 |-> #moveVal ( callcl ( #cpath ( str , len ) , var ( 20 ) , .ExpCLs ) , callcl ( #cpath ( str , len ) , var ( 20 ) , .ExpCLs ) ) , #prodId ( slice ) ) , allocateInit ( 0 |-> #moveVal ( var ( 20 ) , var ( 20 ) )
        1 |-> #moveVal ( callcl ( #cpath ( str , len ) , var ( 20 ) , .ExpCLs ) , callcl ( #cpath ( str , len ) , var ( 20 ) , .ExpCLs ) ) , #prodId ( slice ) ) ) |) }  ;cl fun #cpath ( str , len ) ( var ( 19 ) , .Idents ) { (| #moveVal ( #lenStrcl ( *cl na var ( 19 ) ) , #lenStrcl ( *cl na var ( 19 ) ) ) |) } ;cl fun #cpath ( #prodId ( slice ) , len ) ( var ( 18 ) , .Idents ) { (| #moveVal ( #cvarcl ( *cl na var ( 18 ) .cl valcl ( 1 ) ) , #cvarcl ( *cl na var ( 18 ) .cl valcl ( 1 ) ) ) |) } ;cl fun #cpath ( #prodId ( slice ) , as_ptr ) ( var ( 17 ) , .Idents ) { (| #moveVal ( #rawcl ( *cl na #cvarcl ( *cl na var ( 17 ) .cl valcl ( 0 ) ) ) , #rawcl ( *cl na #cvarcl ( *cl na var ( 17 ) .cl valcl ( 0 ) ) ) ) |) } ;cl fun #cpath ( #prodId ( mem ) , forget ) ( var ( 16 ) , .Idents ) { (| clskip |) } ;cl fun #cpath ( #prodId ( RefCell ) , borrow_mut ) ( var ( 14 ) , .Idents ) { (| ifcl callcl ( #cpath ( #prodId ( Cell ) , get ) , refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 0 ) ) ) , .ExpCLs ) ==cl valcl ( 0 ) thencl (| #paniccl ( *cl na *cl na #refallocate ( allocateInit ( 0 |-> valcl ( "cannot borrow" ) , own ( str ) ) ) ) |) elsecl (| letcl var ( 15 ) =cl callcl ( #cpath ( #prodId ( Cell ) , get ) , refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 0 ) ) ) , .ExpCLs ) incl ( callcl ( #cpath ( #prodId ( Cell ) , set ) , refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 0 ) ) ) , var ( 15 ) +cl valcl ( 1 ) , .ExpCLs ) ;cl clskip ;cl #moveVal ( allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 1 ) ) ) , refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 1 ) ) ) )
        1 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 0 ) ) ) , refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 0 ) ) ) ) , #prodId ( RefMut ) ) , allocateInit ( 0 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 1 ) ) ) , refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 1 ) ) ) )
        1 |-> #moveVal ( refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 0 ) ) ) , refcl ( #cvarcl ( *cl na var ( 14 ) .cl valcl ( 0 ) ) ) ) , #prodId ( RefMut ) ) ) ) |) |) }  ;cl fun #cpath ( #prodId ( RefCell ) , new ) ( var ( 13 ) , .Idents ) { (| #moveVal ( allocateInit ( 0 |-> #moveVal ( callcl ( #cpath ( #prodId ( Cell ) , new ) , valcl ( 0 ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( Cell ) , new ) , valcl ( 0 ) , .ExpCLs ) )
        1 |-> #moveVal ( var ( 13 ) , var ( 13 ) ) , #prodId ( RefCell ) ) , allocateInit ( 0 |-> #moveVal ( callcl ( #cpath ( #prodId ( Cell ) , new ) , valcl ( 0 ) , .ExpCLs ) , callcl ( #cpath ( #prodId ( Cell ) , new ) , valcl ( 0 ) , .ExpCLs ) )
        1 |-> #moveVal ( var ( 13 ) , var ( 13 ) ) , #prodId ( RefCell ) ) ) |) } ;cl fun #cpath ( #prodId ( RefMut ) , drop ) ( var ( 10 ) , .Idents ) { (| letcl var ( 11 ) =cl #cvarcl ( *cl na var ( 10 ) .cl valcl ( 1 ) ) incl letcl var ( 12 ) =cl callcl ( #cpath ( #prodId ( Cell ) , get ) , var ( 11 ) , .ExpCLs ) incl ( callcl ( #cpath ( #prodId ( Cell ) , set ) , var ( 11 ) , var ( 12 ) -cl valcl ( 1 ) , .ExpCLs ) ;cl clskip ) |) } ;cl fun #cpath ( #prodId ( RefMut ) , get ) ( var ( 8 ) , .Idents ) { (| letcl var ( 9 ) =cl #cvarcl ( *cl na var ( 8 ) .cl valcl ( 0 ) ) incl #moveVal ( var ( 9 ) , var ( 9 ) ) |) } ;cl fun #cpath ( #prodId ( Cell ) , set ) ( var ( 6 ) , var ( 7 ) , .Idents ) { (| #cvarcl ( *cl na var ( 6 ) .cl valcl ( 0 ) ) :=cl sc var ( 7 ) ;cl clskip ;cl #moveVal ( #forgetcl ( var ( 7 ) ) , #forgetcl ( var ( 7 ) ) ) |) }  ;cl fun #cpath ( #prodId ( Cell ) , new ) ( var ( 5 ) , .Idents ) { (| #moveVal ( allocateInit ( 0 |-> #moveVal ( var ( 5 ) , var ( 5 ) ) , #prodId ( Cell ) ) , allocateInit ( 0 |-> #moveVal ( var ( 5 ) , var ( 5 ) ) , #prodId ( Cell ) ) ) |) } ;cl fun #cpath ( #prodId ( Cell ) , get ) ( var ( 3 ) , .Idents ) { (| letcl var ( 4 ) =cl #cvarcl ( *cl na var ( 3 ) .cl valcl ( 0 ) ) incl #moveVal ( var ( 4 ) , var ( 4 ) ) |) }  ;cl fun #cpath ( #prodId ( ptr ) , null_mut ) ( .Idents ) { (| #moveVal ( valcl ( -1 ) , valcl ( -1 ) ) |) } ;cl fun #cpath ( #prodId ( ptr ) , null ) ( .Idents ) { (| #moveVal ( valcl ( -1 ) , valcl ( -1 ) ) |) } ;cl fun #cpath ( #prodId ( ptr ) , copy_nonoverlapping ) ( var ( 0 ) , var ( 1 ) , var ( 2 ) , .Idents ) { (| #memcopy ( var ( 0 ) , var ( 1 ) , var ( 2 ) ) ;cl clskip ;cl #forgetcl ( var ( 0 ) ) ;cl clskip ;cl #forgetcl ( var ( 1 ) ) ;cl clskip |) } ;cl

letcl var ( 51 ) =cl callcl ( #cpath ( #prodId ( StringPool ) , new ) , .ExpCLs ) incl ( #move ( callcl ( #cpath ( #prodId ( StringPool ) , new ) , .ExpCLs ) ) ;cl letcl var ( 52 ) =cl #refallocate ( allocateInit ( 0 |-> valcl ( "maybe" ) , own ( str ) ) ) incl ( callcl ( #cpath ( #prodId ( StringPool ) , intern ) , refcl ( var ( 51 ) ) , var ( 52 ) , .ExpCLs ) ;cl clskip ;cl #print ( "{}" , valcl ( 1 ) , .ExpCLs ) ;cl #referto(var(51), *cl na var(52))  ) )
    => #unit
   </k>
      <env> .Map </env>
      <clstack> .List </clstack>
      </thread>
      <cntThreads> 1:Int </cntThreads>
   </threads>

   <OPContext> 
   <closures>
	<closureCnt> N:Int => NT:Int  </closureCnt>
	<funclosure> .Map => Rho:Map </funclosure>
	(.Bag => _ )
   </closures>
        <memory>
	      <memaddress> K:Int => KP:Int </memaddress>
	        <blocks>
	     	 (.Bag => _) 
		</blocks>
	      <memorystatus> .Map => _ </memorystatus>
	      <cntmem> .Map </cntmem>
	  </memory>
   </OPContext>
       <tmpk> .K </tmpk>
       <cpable> SetItem(i32) SetItem(bool) </cpable>
       <output> .List </output>
     </T> 

endmodule

	